<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            min-height: 150px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .error {
            background: #fee;
            border: 1px solid #fcc;
            padding: 12px;
            border-radius: 8px;
            color: #c33;
            margin-top: 10px;
            display: none;
        }

        #graph {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .node circle {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 2px;
            transition: all 0.3s;
        }

        .node circle:hover {
            stroke-width: 4px;
        }

        .node text {
            font-size: 12px;
            pointer-events: none;
            user-select: none;
            font-weight: 600;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
            fill: none;
        }

        .link.external {
            stroke: #ff6b6b;
            stroke-dasharray: 5,5;
        }

        .link-label {
            font-size: 10px;
            fill: #666;
            pointer-events: none;
            user-select: none;
        }

        .arrow {
            fill: #999;
        }

        .arrow.external {
            fill: #ff6b6b;
        }

        .legend {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-line {
            width: 40px;
            height: 2px;
            margin-right: 10px;
        }

        .legend-line.internal {
            background: #999;
        }

        .legend-line.external {
            background: #ff6b6b;
            background-image: repeating-linear-gradient(90deg, #ff6b6b, #ff6b6b 5px, transparent 5px, transparent 10px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”— Graph Visualizer</h1>
        
        <div class="controls">
            <div class="input-group">
                <label for="jsonInput">Paste your Graph JSON:</label>
                <textarea id="jsonInput" placeholder='{"nodes": {"A": {"name": "A", "edges": [{"to": "B", "name": "edge1"}]}, "B": {"name": "B", "edges": []}}, "external": {"C": [{"to": "A", "name": "external1"}]}}'></textarea>
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="renderGraph()">Visualize Graph</button>
                <button onclick="formatJSON()" style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);">Format JSON</button>
            </div>
            <div class="error" id="error"></div>
        </div>

        <div id="graph"></div>

        <div class="legend">
            <h3>Legend</h3>
            <div class="legend-item">
                <div class="legend-line internal"></div>
                <span>Internal Edge</span>
            </div>
            <div class="legend-item">
                <div class="legend-line external"></div>
                <span>External Edge</span>
            </div>
        </div>
    </div>

    <script>
        const width = 1200;
        const height = 700;

        // Check for data in URL query parameter on load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const dataParam = urlParams.get('data');
            
            if (dataParam) {
                try {
                    const jsonString = atob(dataParam);
                    document.getElementById('jsonInput').value = jsonString;
                    renderGraph();
                    return;
                } catch (e) {
                    console.error('Failed to decode URL parameter:', e);
                }
            }
            
            // Load example if no URL parameter
            document.getElementById('jsonInput').value = JSON.stringify(exampleGraph, null, 2);
            renderGraph();
        });

        function formatJSON() {
            const input = document.getElementById('jsonInput').value;
            const errorDiv = document.getElementById('error');
            errorDiv.style.display = 'none';

            if (!input.trim()) {
                errorDiv.textContent = 'Please paste JSON to format';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const parsed = JSON.parse(input);
                document.getElementById('jsonInput').value = JSON.stringify(parsed, null, 2);
            } catch (e) {
                errorDiv.textContent = 'Invalid JSON: ' + e.message;
                errorDiv.style.display = 'block';
            }
        }

        function renderGraph() {
            const input = document.getElementById('jsonInput').value;
            const errorDiv = document.getElementById('error');
            errorDiv.style.display = 'none';

            if (!input.trim()) {
                errorDiv.textContent = 'Please paste a graph JSON';
                errorDiv.style.display = 'block';
                return;
            }

            let graphData;
            try {
                graphData = JSON.parse(input);
            } catch (e) {
                errorDiv.textContent = 'Invalid JSON: ' + e.message;
                errorDiv.style.display = 'block';
                return;
            }

            // Clear previous graph
            d3.select('#graph').html('');

            // Convert graph data to D3 format
            const nodes = [];
            const links = [];
            const nodeSet = new Set();

            // Add all internal nodes
            if (graphData.nodes) {
                Object.entries(graphData.nodes).forEach(([key, node]) => {
                    if (!nodeSet.has(key)) {
                        nodes.push({ id: key, label: node.name, type: 'internal' });
                        nodeSet.add(key);
                    }

                    // Add internal edges
                    if (node.edges) {
                        node.edges.forEach(edge => {
                            if (!nodeSet.has(edge.to)) {
                                // Check if this target exists in nodes map
                                const targetNode = graphData.nodes[edge.to];
                                const targetLabel = targetNode ? targetNode.name : edge.to;
                                nodes.push({ id: edge.to, label: targetLabel, type: 'internal' });
                                nodeSet.add(edge.to);
                            }
                            links.push({
                                source: key,
                                target: edge.to,
                                label: edge.name,
                                external: false
                            });
                        });
                    }
                });
            }

            // Add external edges
            if (graphData.external) {
                Object.entries(graphData.external).forEach(([from, edges]) => {
                    if (!nodeSet.has(from)) {
                        nodes.push({ id: from, type: 'external' });
                        nodeSet.add(from);
                    }

                    edges.forEach(edge => {
                        if (!nodeSet.has(edge.to)) {
                            nodes.push({ id: edge.to, type: 'external' });
                            nodeSet.add(edge.to);
                        }
                        links.push({
                            source: from,
                            target: edge.to,
                            label: edge.name,
                            external: true
                        });
                    });
                });
            }

            // Create SVG
            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Define arrow markers
            svg.append('defs').selectAll('marker')
                .data(['arrow', 'arrow-external'])
                .join('marker')
                .attr('id', d => d)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 25)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('class', d => d === 'arrow-external' ? 'arrow external' : 'arrow');

            // Create force simulation with better untangling
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(200).strength(1))
                .force('charge', d3.forceManyBody().strength(-1000).distanceMax(500))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(50))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05))
                .alphaDecay(0.01)
                .velocityDecay(0.3);

            // Create links
            const link = svg.append('g')
                .selectAll('path')
                .data(links)
                .join('path')
                .attr('class', d => d.external ? 'link external' : 'link')
                .attr('marker-end', d => d.external ? 'url(#arrow-external)' : 'url(#arrow)');

            // Create link labels
            const linkLabel = svg.append('g')
                .selectAll('text')
                .data(links.filter(d => d.label))
                .join('text')
                .attr('class', 'link-label')
                .text(d => d.label);

            // Create nodes
            const node = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('circle')
                .attr('r', 20)
                .attr('fill', d => d.type === 'external' ? '#ff6b6b' : '#667eea');

            node.append('text')
                .attr('dy', 35)
                .attr('text-anchor', 'middle')
                .text(d => d.label || d.id);

            // Update positions on tick
            simulation.on('tick', () => {
                link.attr('d', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                });

                linkLabel
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        // Example graph on load
        const exampleGraph = {
            "nodes": {
                "A": {
                    "name": "A",
                    "edges": [
                        {"to": "B", "name": "connects"},
                        {"to": "C", "name": "links"}
                    ]
                },
                "B": {
                    "name": "B",
                    "edges": [
                        {"to": "D", "name": "flows"}
                    ]
                },
                "C": {
                    "name": "C",
                    "edges": [
                        {"to": "D", "name": "points"}
                    ]
                },
                "D": {
                    "name": "D",
                    "edges": []
                }
            },
            "external": {
                "E": [
                    {"to": "A", "name": "external"}
                ]
            }
        };
    </script>
</body>
</html>