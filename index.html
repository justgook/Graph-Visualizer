<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Level Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e22ce 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .nav {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      padding: 0;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .nav-content {
      max-width: 1600px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      padding: 0 20px;
    }

    .nav-brand {
      font-size: 20px;
      font-weight: 700;
      color: #1e3c72;
      padding: 18px 0;
      margin-right: 40px;
    }

    .nav-links {
      display: flex;
      gap: 0;
      list-style: none;
    }

    .nav-links a {
      display: block;
      padding: 20px 24px;
      color: #555;
      text-decoration: none;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s;
      border-bottom: 3px solid transparent;
    }

    .nav-links a:hover {
      color: #1e3c72;
      background: rgba(30, 60, 114, 0.05);
    }

    .nav-links a.active {
      color: #7e22ce;
      border-bottom-color: #7e22ce;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 30px 20px;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 25px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    h1 {
      background: linear-gradient(135deg, #1e3c72 0%, #7e22ce 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 8px;
      font-size: 28px;
    }

    .subtitle {
      color: #666;
      font-size: 14px;
      margin-bottom: 20px;
    }

    .input-section {
      margin-bottom: 18px;
    }

    label {
      display: block;
      margin-bottom: 10px;
      color: #333;
      font-weight: 600;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      min-height: 180px;
      padding: 16px;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      resize: vertical;
      transition: all 0.3s;
      background: #fafafa;
    }

    textarea:focus {
      outline: none;
      border-color: #7e22ce;
      background: white;
      box-shadow: 0 0 0 3px rgba(126, 34, 206, 0.1);
    }

    .button-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
      box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
    }

    button.secondary:hover {
      box-shadow: 0 6px 20px rgba(108, 117, 125, 0.4);
    }

    .canvas-container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 25px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.3);
      position: relative;
    }

    .canvas-wrapper {
      position: relative;
      overflow: hidden;
      border: 2px solid #f0f0f0;
      border-radius: 12px;
      background: #fafafa;
      cursor: grab;
      height: 600px;
    }

    .canvas-wrapper:active {
      cursor: grabbing;
    }

    #canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    .controls {
      position: absolute;
      top: 35px;
      right: 35px;
      display: flex;
      gap: 8px;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 10;
    }

    .control-btn {
      width: 36px;
      height: 36px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      min-width: auto;
      border-radius: 6px;
    }

    .zoom-level {
      padding: 8px 12px;
      background: rgba(126, 34, 206, 0.1);
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      color: #7e22ce;
      display: flex;
      align-items: center;
    }

    .edge-indicators {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 5;
    }

    .indicator {
      position: absolute;
      background: rgba(126, 34, 206, 0.8);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      display: none;
      align-items: center;
      gap: 6px;
    }

    .indicator.visible {
      display: flex;
    }

    .indicator.top {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
    }

    .indicator.bottom {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
    }

    .indicator.left {
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
    }

    .indicator.right {
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
    }

    .error {
      background: linear-gradient(135deg, #fee 0%, #fdd 100%);
      border: 2px solid #fcc;
      border-radius: 10px;
      padding: 14px;
      color: #c33;
      margin-top: 12px;
      display: none;
      font-weight: 500;
    }

    .info {
      color: #666;
      font-size: 13px;
      margin-top: 8px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .header,
    .canvas-container {
      animation: fadeIn 0.5s ease-out;
    }
  </style>
</head>

<body>
  <nav class="nav">
    <div class="nav-content">
      <div class="nav-brand">üéÆ Game Dev Tools</div>
      <ul class="nav-links">
        <li><a href="/" class="active">Level Visualizer</a></li>
        <li><a href="graph-viz.html">Graph Visualizer</a></li>
      </ul>
    </div>
  </nav>

  <div class="container">
    <div class="header">
      <h1>üå≥ Level Visualizer</h1>
      <div class="subtitle">Visualize your game level tree structure with style</div>

      <div class="input-section">
        <label for="jsonInput">Tree JSON Data:</label>
        <textarea id="jsonInput"
          placeholder='{"nodes": {"root": {"name": "Root", "data": {}, ...}}, "root": "root"}'></textarea>
        <div class="info">Paste the JSON output from your tree.ToJSON() method or use ?data=base64 URL parameter. Graph will auto-fit to screen on load. Use mouse wheel + Ctrl to zoom, drag to pan</div>
      </div>

      <div class="button-group">
        <button onclick="visualize()">‚ú® Visualize Tree</button>
        <button class="secondary" onclick="formatJSON()">üìù Format JSON</button>
        <button class="secondary" onclick="fitToContent()">üîç Fit to Screen</button>
        <button class="secondary" onclick="resetView()">üîÑ Reset View</button>
      </div>

      <div id="error" class="error"></div>
    </div>

    <div class="canvas-container">
      <div class="controls">
        <button class="control-btn" onclick="zoomIn()" title="Zoom In">+</button>
        <button class="control-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button>
        <div class="zoom-level" id="zoomLevel">100%</div>
      </div>
      <div class="canvas-wrapper" id="canvasWrapper">
        <canvas id="canvas"></canvas>
        <div class="edge-indicators">
          <div class="indicator top" id="indicatorTop">‚Üë Content above</div>
          <div class="indicator bottom" id="indicatorBottom">‚Üì Content below</div>
          <div class="indicator left" id="indicatorLeft">‚Üê Content left</div>
          <div class="indicator right" id="indicatorRight">‚Üí Content right</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvasWrapper');
    let tree = null;
    let nodePositions = {};
    let nodeSizes = {};
    let nodeSpacingRequirements = {};
    let edgeLabelBounds = []; // Track edge label positions to prevent overlap
    let expandedNodes = new Set();
    let contentBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

    // Transform state
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    const NODE_MIN_WIDTH = 200;
    const NODE_PADDING = 16;
    const HORIZONTAL_SPACING = 150;
    const VERTICAL_SPACING = 50;
    const MIN_VERTICAL_SPACING = 50;
    const PADDING = 100;
    const LINE_HEIGHT = 18;
    const MAX_VISIBLE_DATA = 3;
    const GRID_SIZE = 40;
    const MIN_SCALE = 0.2;
    const MAX_SCALE = 3;
    const EDGE_LABEL_PADDING = 10;

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
    }

    function hideError() {
      document.getElementById('error').style.display = 'none';
    }

    function updateZoomDisplay() {
      document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
    }

    function constrainPosition() {
      if (!tree) return;

      const wrapperWidth = wrapper.offsetWidth;
      const wrapperHeight = wrapper.offsetHeight;
      const contentWidth = canvas.width * scale;
      const contentHeight = canvas.height * scale;

      const minVisibleWidth = Math.min(wrapperWidth * 0.3, contentWidth);
      const minVisibleHeight = Math.min(wrapperHeight * 0.3, contentHeight);

      const maxOffsetX = wrapperWidth - minVisibleWidth;
      const minOffsetX = -(contentWidth - minVisibleWidth);
      const maxOffsetY = wrapperHeight - minVisibleHeight;
      const minOffsetY = -(contentHeight - minVisibleHeight);

      offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
      offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
    }

    function updateEdgeIndicators() {
      if (!tree) return;

      const wrapperWidth = wrapper.offsetWidth;
      const wrapperHeight = wrapper.offsetHeight;

      const indicatorTop = document.getElementById('indicatorTop');
      const indicatorBottom = document.getElementById('indicatorBottom');
      const indicatorLeft = document.getElementById('indicatorLeft');
      const indicatorRight = document.getElementById('indicatorRight');

      const threshold = 5; // Pixels of tolerance

      // Calculate actual content bounds in screen space
      const contentLeft = contentBounds.minX * scale + offsetX;
      const contentRight = contentBounds.maxX * scale + offsetX;
      const contentTop = contentBounds.minY * scale + offsetY;
      const contentBottom = contentBounds.maxY * scale + offsetY;

      // Content is above viewport when top of content is above viewport
      indicatorTop.classList.toggle('visible', contentTop < -threshold);
      // Content is below viewport when bottom of content is below viewport
      indicatorBottom.classList.toggle('visible', contentBottom > wrapperHeight + threshold);
      // Content is to the left when left of content is left of viewport
      indicatorLeft.classList.toggle('visible', contentLeft < -threshold);
      // Content is to the right when right of content is right of viewport
      indicatorRight.classList.toggle('visible', contentRight > wrapperWidth + threshold);
    }

    function zoomIn() {
      const centerX = wrapper.offsetWidth / 2;
      const centerY = wrapper.offsetHeight / 2;
      zoom(centerX, centerY, 1.2);
    }

    function zoomOut() {
      const centerX = wrapper.offsetWidth / 2;
      const centerY = wrapper.offsetHeight / 2;
      zoom(centerX, centerY, 0.8);
    }

    function zoom(x, y, factor) {
      const oldScale = scale;
      scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * factor));
      
      const scaleChange = scale - oldScale;
      const relX = (x - offsetX) / oldScale;
      const relY = (y - offsetY) / oldScale;
      
      offsetX -= relX * scaleChange;
      offsetY -= relY * scaleChange;
      
      constrainPosition();
      updateZoomDisplay();
      updateEdgeIndicators();
      draw();
    }

    function resetView() {
      scale = 1;
      offsetX = 0;
      offsetY = 0;
      updateZoomDisplay();
      if (tree) {
        calculateLayout();
        constrainPosition();
        updateEdgeIndicators();
        draw();
      }
    }

    function fitToContent() {
      if (!tree || !contentBounds) return;
      
      const wrapperWidth = wrapper.offsetWidth;
      const wrapperHeight = wrapper.offsetHeight;
      
      // Calculate content dimensions
      const contentWidth = contentBounds.maxX - contentBounds.minX;
      const contentHeight = contentBounds.maxY - contentBounds.minY;
      
      // Add padding around content
      const paddingFactor = 1.1; // 10% padding
      const targetWidth = contentWidth * paddingFactor;
      const targetHeight = contentHeight * paddingFactor;
      
      // Calculate scale to fit content
      const scaleX = wrapperWidth / targetWidth;
      const scaleY = wrapperHeight / targetHeight;
      let newScale = Math.min(scaleX, scaleY);
      
      // Clamp scale to allowed range
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      
      // If content is too large even at minimum scale, prioritize showing the root
      if (newScale === MIN_SCALE && tree.root && nodePositions[tree.root]) {
        scale = MIN_SCALE;
        
        // Center on root node
        const rootPos = nodePositions[tree.root];
        const rootCenterX = rootPos.x + rootPos.width / 2;
        const rootCenterY = rootPos.y + rootPos.height / 2;
        
        offsetX = wrapperWidth / 2 - rootCenterX * scale;
        offsetY = wrapperHeight / 2 - rootCenterY * scale;
      } else {
        // Fit entire content
        scale = newScale;
        
        // Center the content
        const contentCenterX = (contentBounds.minX + contentBounds.maxX) / 2;
        const contentCenterY = (contentBounds.minY + contentBounds.maxY) / 2;
        
        offsetX = wrapperWidth / 2 - contentCenterX * scale;
        offsetY = wrapperHeight / 2 - contentCenterY * scale;
      }
      
      updateZoomDisplay();
      constrainPosition();
      updateEdgeIndicators();
      draw();
    }

    // Mouse wheel zoom
    wrapper.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = wrapper.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      if (e.ctrlKey || e.metaKey) {
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        zoom(x, y, factor);
      } else {
        offsetX -= e.deltaX;
        offsetY -= e.deltaY;
        constrainPosition();
        updateEdgeIndicators();
        draw();
      }
    }, { passive: false });

    // Mouse drag
    wrapper.addEventListener('mousedown', (e) => {
      const rect = wrapper.getBoundingClientRect();
      const x = (e.clientX - rect.left - offsetX) / scale;
      const y = (e.clientY - rect.top - offsetY) / scale;
      
      const clicked = checkExpandButtonClick(x, y);
      if (clicked) {
        return;
      }
      
      isDragging = true;
      dragStartX = e.clientX - offsetX;
      dragStartY = e.clientY - offsetY;
    });

    wrapper.addEventListener('mousemove', (e) => {
      if (isDragging) {
        offsetX = e.clientX - dragStartX;
        offsetY = e.clientY - dragStartY;
        constrainPosition();
        updateEdgeIndicators();
        draw();
      }
    });

    wrapper.addEventListener('mouseup', () => {
      isDragging = false;
    });

    wrapper.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Resize handler
    window.addEventListener('resize', () => {
      if (tree) {
        calculateLayout();
        constrainPosition();
        updateEdgeIndicators();
        draw();
      }
    });

    function checkExpandButtonClick(x, y) {
      for (const [nodeId, pos] of Object.entries(nodePositions)) {
        const node = tree.nodes[nodeId];
        if (!node.data || Object.keys(node.data).length <= MAX_VISIBLE_DATA) continue;
        
        const buttonY = pos.y + pos.height - NODE_PADDING - 26;
        const buttonX = pos.x + NODE_PADDING;
        const buttonWidth = pos.width - NODE_PADDING * 2;
        const buttonHeight = 26;
        
        if (x >= buttonX && x <= buttonX + buttonWidth &&
            y >= buttonY && y <= buttonY + buttonHeight) {
          if (expandedNodes.has(nodeId)) {
            expandedNodes.delete(nodeId);
          } else {
            expandedNodes.add(nodeId);
          }
          calculateLayout();
          constrainPosition();
          updateEdgeIndicators();
          draw();
          return true;
        }
      }
      return false;
    }

    function wrapText(text, maxWidth) {
      const words = text.split(' ');
      const lines = [];
      let currentLine = words[0];

      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const width = ctx.measureText(currentLine + ' ' + word).width;
        if (width < maxWidth) {
          currentLine += ' ' + word;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      lines.push(currentLine);
      return lines;
    }

    function calculateEdgeLabelSize(edgeName) {
      if (!edgeName) return { width: 0, height: 0 };
      
      ctx.font = 'bold 12px Arial';
      
      // Estimate max label width as a portion of typical edge length
      const maxLabelWidth = HORIZONTAL_SPACING * 0.5;
      const lines = wrapText(edgeName, maxLabelWidth);
      const lineHeight = 16;
      
      const textWidths = lines.map(line => ctx.measureText(line).width);
      const maxTextWidth = Math.max(...textWidths);
      const pillPadding = 8;
      
      return {
        width: maxTextWidth + pillPadding * 2,
        height: lines.length * lineHeight + pillPadding * 2
      };
    }

    function calculateNodeSize(nodeId) {
      const node = tree.nodes[nodeId];
      ctx.font = 'bold 15px Arial';
      const nameWidth = ctx.measureText(node.name || nodeId).width;
      
      let maxWidth = Math.max(NODE_MIN_WIDTH, nameWidth + NODE_PADDING * 2);
      let height = NODE_PADDING * 2 + 20;
      
      if (node.data && Object.keys(node.data).length > 0) {
        ctx.font = '12px Arial';
        const dataEntries = Object.entries(node.data);
        const isExpanded = expandedNodes.has(nodeId);
        const visibleCount = isExpanded ? dataEntries.length : Math.min(MAX_VISIBLE_DATA, dataEntries.length);
        
        dataEntries.slice(0, visibleCount).forEach(([key, value]) => {
          const text = `${key}: ${value}`;
          const textWidth = ctx.measureText(text).width;
          maxWidth = Math.max(maxWidth, textWidth + NODE_PADDING * 3);
        });
        
        height += LINE_HEIGHT * visibleCount + 8;
        
        if (dataEntries.length > MAX_VISIBLE_DATA) {
          height += 34;
        }
      }
      
      return { width: maxWidth, height };
    }

    function loadExample() {
      const example = {
        "nodes": {
          "root": {
            "name": "Tutorial",
            "data": {"difficulty": "easy", "type": "intro", "time": "5min"},
            "children": [
              {"to": "level1", "name": "Next Level"},
              {"to": "bonus1", "name": "Secret Path"}
            ]
          },
          "level1": {
            "name": "Forest Path",
            "data": {"difficulty": "medium", "enemies": "3", "collectibles": "5", "hazards": "spikes", "weather": "rain"},
            "parent": "root",
            "children": [
              {"to": "level2a", "name": "Main Route"},
              {"to": "level2b", "name": "Alternate Path"}
            ]
          },
          "bonus1": {
            "name": "Hidden Cave",
            "data": {"difficulty": "hard", "reward": "legendary sword", "hidden": "true"},
            "parent": "root"
          },
          "level2a": {
            "name": "Mountain Pass",
            "data": {"difficulty": "hard", "boss": "Dragon", "checkpoint": "yes"},
            "parent": "level1"
          },
          "level2b": {
            "name": "River Valley",
            "data": {"difficulty": "medium", "puzzle": "bridge"},
            "parent": "level1"
          }
        },
        "root": "root"
      };

      document.getElementById('jsonInput').value = JSON.stringify(example, null, 2);
      visualize();
    }

    function formatJSON() {
      const input = document.getElementById('jsonInput').value.trim();

      if (!input) {
        showError('Nothing to format');
        return;
      }

      try {
        const parsed = JSON.parse(input);
        document.getElementById('jsonInput').value = JSON.stringify(parsed, null, 2);
        hideError();
      } catch (e) {
        showError('Invalid JSON: ' + e.message);
      }
    }

    function Initialize() {
      const urlParams = new URLSearchParams(window.location.search);
      const dataParam = urlParams.get('data');

      if (dataParam) {
        try {
          const decoded = atob(dataParam);
          const parsed = JSON.parse(decoded);
          document.getElementById('jsonInput').value = JSON.stringify(parsed, null, 2);
          visualize();
        } catch (e) {
          showError('Invalid data parameter: ' + e.message);
        }
      } else {
        loadExample()
      }
    }

    function visualize() {
      hideError();
      const input = document.getElementById('jsonInput').value.trim();

      if (!input) {
        showError('Please paste your tree JSON data');
        return;
      }

      try {
        tree = JSON.parse(input);

        if (!tree.nodes || !tree.root) {
          showError('Invalid tree format. Must have "nodes" and "root" properties');
          return;
        }

        expandedNodes.clear();
        calculateLayout();
        fitToContent(); // Auto-fit to show entire graph or center on root
        draw();
      } catch (e) {
        showError('Invalid JSON: ' + e.message);
      }
    }

    function calculateLayout() {
      nodePositions = {};
      const levels = {};
      const nodeSizes = {};
      const edgeLabelSizes = {};

      function calculateSizes(nodeId) {
        if (nodeSizes[nodeId]) return;
        const size = calculateNodeSize(nodeId);
        nodeSizes[nodeId] = size;
        
        const node = tree.nodes[nodeId];
        if (node && node.children) {
          node.children.forEach(child => {
            calculateSizes(child.to);
            // Calculate edge label size
            if (child.name) {
              const labelSize = calculateEdgeLabelSize(child.name);
              edgeLabelSizes[`${nodeId}-${child.to}`] = labelSize;
            }
          });
        }
      }

      function assignLevels(nodeId, level = 0) {
        if (!levels[level]) {
          levels[level] = [];
        }
        levels[level].push(nodeId);

        const node = tree.nodes[nodeId];
        if (node && node.children) {
          node.children.forEach(child => {
            assignLevels(child.to, level + 1);
          });
        }
      }

      calculateSizes(tree.root);
      assignLevels(tree.root);

      // Calculate spacing requirements per node pair
      const nodeSpacingRequirements = {};
      Object.keys(levels).forEach(level => {
        const nodesAtLevel = levels[level];
        nodesAtLevel.forEach((nodeId, index) => {
          if (index === nodesAtLevel.length - 1) return;
          
          const nextNodeId = nodesAtLevel[index + 1];
          let maxLabelHeight = 0;
          
          // Check all edges from current node
          const node = tree.nodes[nodeId];
          if (node && node.children) {
            node.children.forEach(child => {
              const labelSize = edgeLabelSizes[`${nodeId}-${child.to}`];
              if (labelSize) {
                maxLabelHeight = Math.max(maxLabelHeight, labelSize.height);
              }
            });
          }
          
          // Check all edges from next node
          const nextNode = tree.nodes[nextNodeId];
          if (nextNode && nextNode.children) {
            nextNode.children.forEach(child => {
              const labelSize = edgeLabelSizes[`${nextNodeId}-${child.to}`];
              if (labelSize) {
                maxLabelHeight = Math.max(maxLabelHeight, labelSize.height);
              }
            });
          }
          
          // Also check edges coming INTO current and next nodes from previous level
          if (parseInt(level) > 0) {
            const prevLevel = (parseInt(level) - 1).toString();
            if (levels[prevLevel]) {
              levels[prevLevel].forEach(prevNodeId => {
                const prevNode = tree.nodes[prevNodeId];
                if (prevNode && prevNode.children) {
                  prevNode.children.forEach(child => {
                    if (child.to === nodeId || child.to === nextNodeId) {
                      const labelSize = edgeLabelSizes[`${prevNodeId}-${child.to}`];
                      if (labelSize) {
                        maxLabelHeight = Math.max(maxLabelHeight, labelSize.height);
                      }
                    }
                  });
                }
              });
            }
          }
          
          nodeSpacingRequirements[`${nodeId}-${nextNodeId}`] = maxLabelHeight;
        });
      });

      let totalHeight = PADDING * 2;
      Object.keys(levels).forEach(level => {
        const nodesAtLevel = levels[level];
        let levelHeight = 0;
        
        nodesAtLevel.forEach((nodeId, index) => {
          levelHeight += nodeSizes[nodeId].height;
          
          if (index < nodesAtLevel.length - 1) {
            const nextNodeId = nodesAtLevel[index + 1];
            const requiredSpace = nodeSpacingRequirements[`${nodeId}-${nextNodeId}`] || 0;
            const spacing = Math.max(MIN_VERTICAL_SPACING, requiredSpace + EDGE_LABEL_PADDING * 2);
            levelHeight += spacing;
          }
        });
        
        totalHeight = Math.max(totalHeight, levelHeight);
      });

      let totalWidth = PADDING * 2;
      Object.keys(levels).forEach(level => {
        const maxWidth = Math.max(...levels[level].map(nodeId => nodeSizes[nodeId].width));
        totalWidth += maxWidth + HORIZONTAL_SPACING;
      });

      const wrapperWidth = wrapper.offsetWidth;
      const wrapperHeight = wrapper.offsetHeight;
      canvas.width = Math.max(totalWidth, wrapperWidth);
      canvas.height = Math.max(totalHeight, wrapperHeight);

      // Calculate content bounding box
      contentBounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

      // Position nodes with dynamic spacing per pair
      Object.keys(levels).forEach((level, levelIndex) => {
        const nodesAtLevel = levels[level];
        
        let levelHeight = 0;
        nodesAtLevel.forEach((nodeId, index) => {
          levelHeight += nodeSizes[nodeId].height;
          
          if (index < nodesAtLevel.length - 1) {
            const nextNodeId = nodesAtLevel[index + 1];
            const requiredSpace = nodeSpacingRequirements[`${nodeId}-${nextNodeId}`] || 0;
            const spacing = Math.max(MIN_VERTICAL_SPACING, requiredSpace + EDGE_LABEL_PADDING * 2);
            levelHeight += spacing;
          }
        });
        
        const startY = (canvas.height - levelHeight) / 2;

        let currentX = PADDING;
        for (let i = 0; i < levelIndex; i++) {
          const prevLevelMaxWidth = Math.max(...levels[i].map(nodeId => nodeSizes[nodeId].width));
          currentX += prevLevelMaxWidth + HORIZONTAL_SPACING;
        }

        let currentY = startY;
        nodesAtLevel.forEach((nodeId, index) => {
          const size = nodeSizes[nodeId];
          nodePositions[nodeId] = {
            x: currentX,
            y: currentY,
            width: size.width,
            height: size.height
          };
          
          // Update content bounds
          contentBounds.minX = Math.min(contentBounds.minX, currentX);
          contentBounds.minY = Math.min(contentBounds.minY, currentY);
          contentBounds.maxX = Math.max(contentBounds.maxX, currentX + size.width);
          contentBounds.maxY = Math.max(contentBounds.maxY, currentY + size.height);
          
          currentY += size.height;
          
          if (index < nodesAtLevel.length - 1) {
            const nextNodeId = nodesAtLevel[index + 1];
            const requiredSpace = nodeSpacingRequirements[`${nodeId}-${nextNodeId}`] || 0;
            const spacing = Math.max(MIN_VERTICAL_SPACING, requiredSpace + EDGE_LABEL_PADDING * 2);
            currentY += spacing;
          }
        });
      });
    }

    function drawGrid() {
      const wrapperWidth = wrapper.offsetWidth;
      const wrapperHeight = wrapper.offsetHeight;
      
      // Calculate visible area in canvas coordinates
      const viewStartX = -offsetX / scale;
      const viewStartY = -offsetY / scale;
      const viewEndX = (wrapperWidth - offsetX) / scale;
      const viewEndY = (wrapperHeight - offsetY) / scale;
      
      // Calculate grid offset to make it appear stationary
      const gridOffsetX = viewStartX - (viewStartX % GRID_SIZE);
      const gridOffsetY = viewStartY - (viewStartY % GRID_SIZE);
      
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1 / scale;
      
      // Draw vertical lines
      for (let x = gridOffsetX; x <= viewEndX; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, viewStartY);
        ctx.lineTo(x, viewEndY);
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = gridOffsetY; y <= viewEndY; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(viewStartX, y);
        ctx.lineTo(viewEndX, y);
        ctx.stroke();
      }
    }

    function checkLabelOverlap(bounds) {
      // Check if a label overlaps with any existing labels
      for (const existing of edgeLabelBounds) {
        if (!(bounds.right < existing.left || 
              bounds.left > existing.right || 
              bounds.bottom < existing.top || 
              bounds.top > existing.bottom)) {
          return true; // Overlap detected
        }
      }
      return false;
    }

    function findNonOverlappingPosition(midX, midY, width, height, startY, endY) {
      // Try different vertical offsets to find a non-overlapping position
      const offsets = [0, 20, -20, 40, -40, 60, -60, 80, -80];
      
      for (const offset of offsets) {
        const testY = midY + offset;
        const bounds = {
          left: midX - width / 2,
          right: midX + width / 2,
          top: testY - height / 2,
          bottom: testY + height / 2
        };
        
        // Make sure the label stays within reasonable bounds of the edge
        const edgeMinY = Math.min(startY, endY) - 100;
        const edgeMaxY = Math.max(startY, endY) + 100;
        
        if (testY - height / 2 >= edgeMinY && 
            testY + height / 2 <= edgeMaxY && 
            !checkLabelOverlap(bounds)) {
          return { x: midX, y: testY, bounds };
        }
      }
      
      // If no non-overlapping position found, return original with bounds
      const bounds = {
        left: midX - width / 2,
        right: midX + width / 2,
        top: midY - height / 2,
        bottom: midY + height / 2
      };
      return { x: midX, y: midY, bounds };
    }

    function draw() {
      const wrapperWidth = wrapper.offsetWidth;
      const wrapperHeight = wrapper.offsetHeight;
      
      // Reset edge label bounds for overlap detection
      edgeLabelBounds = [];
      
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);

      // Draw gradient background
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#f8f9fa');
      gradient.addColorStop(1, '#e9ecef');
      ctx.fillStyle = gradient;
      ctx.fillRect(-offsetX / scale, -offsetY / scale, wrapperWidth / scale, wrapperHeight / scale);

      // Draw grid
      drawGrid();

      // Draw edges
      Object.keys(tree.nodes).forEach(nodeId => {
        const node = tree.nodes[nodeId];
        if (node.children) {
          node.children.forEach(edge => {
            drawEdge(nodeId, edge.to, edge.name);
          });
        }
      });

      // Draw nodes
      Object.keys(nodePositions).forEach(nodeId => {
        drawNode(nodeId);
      });

      ctx.restore();
    }

    function drawEdge(fromId, toId, edgeName) {
      const from = nodePositions[fromId];
      const to = nodePositions[toId];

      if (!from || !to) return;

      const startX = from.x + from.width;
      const startY = from.y + from.height / 2;
      const endX = to.x;
      const endY = to.y + to.height / 2;

      ctx.shadowBlur = 10 / scale;
      ctx.shadowColor = 'rgba(102, 126, 234, 0.3)';

      const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
      gradient.addColorStop(0, '#667eea');
      gradient.addColorStop(1, '#764ba2');
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(startX, startY);

      const controlX = startX + (endX - startX) / 2;
      ctx.bezierCurveTo(controlX, startY, controlX, endY, endX, endY);
      ctx.stroke();

      ctx.shadowBlur = 0;

      const arrowSize = 10;
      ctx.fillStyle = '#764ba2';
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - arrowSize, endY - arrowSize / 2);
      ctx.lineTo(endX - arrowSize, endY + arrowSize / 2);
      ctx.closePath();
      ctx.fill();

      if (edgeName) {
        const midX = startX + (endX - startX) / 2;
        const midY = startY + (endY - startY) / 2;

        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Wrap text if needed
        const maxLabelWidth = Math.abs(endX - startX) * 0.4;
        const lines = wrapText(edgeName, maxLabelWidth);
        const lineHeight = 16;
        const totalTextHeight = lines.length * lineHeight;

        const textWidths = lines.map(line => ctx.measureText(line).width);
        const maxTextWidth = Math.max(...textWidths);
        
        const pillPadding = 8;
        const pillHeight = totalTextHeight + pillPadding * 2;
        const pillWidth = maxTextWidth + pillPadding * 2;
        
        // Find a non-overlapping position for this label
        const position = findNonOverlappingPosition(midX, midY, pillWidth, pillHeight, startY, endY);
        
        // Store the bounds of this label
        edgeLabelBounds.push(position.bounds);
        
        // Draw the label at the adjusted position
        ctx.fillStyle = 'rgba(126, 34, 206, 0.95)';
        ctx.beginPath();
        ctx.roundRect(position.x - pillWidth / 2, position.y - pillHeight / 2, 
                      pillWidth, pillHeight, 11);
        ctx.fill();

        ctx.fillStyle = 'white';
        const textStartY = position.y - (lines.length - 1) * lineHeight / 2;
        lines.forEach((line, i) => {
          ctx.fillText(line, position.x, textStartY + i * lineHeight);
        });
      }
    }

    function drawNode(nodeId) {
      const pos = nodePositions[nodeId];
      if (!pos) return;

      const node = tree.nodes[nodeId];
      const isRoot = nodeId === tree.root;

      ctx.shadowBlur = 15 / scale;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
      ctx.shadowOffsetY = 4 / scale;

      const radius = 12;
      const gradient = ctx.createLinearGradient(pos.x, pos.y, pos.x, pos.y + pos.height);
      if (isRoot) {
        gradient.addColorStop(0, '#7e22ce');
        gradient.addColorStop(1, '#6b21a8');
      } else {
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(1, '#5568d3');
      }

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.roundRect(pos.x, pos.y, pos.width, pos.height, radius);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      ctx.strokeStyle = isRoot ? '#6b21a8' : '#5568d3';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = 'white';
      ctx.font = 'bold 15px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const text = node.name || nodeId;
      ctx.fillText(text, pos.x + pos.width / 2, pos.y + NODE_PADDING);

      if (node.data && Object.keys(node.data).length > 0) {
        ctx.font = '12px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.textAlign = 'left';
        let dataY = pos.y + NODE_PADDING + 30;

        const dataEntries = Object.entries(node.data);
        const isExpanded = expandedNodes.has(nodeId);
        const visibleCount = isExpanded ? dataEntries.length : Math.min(MAX_VISIBLE_DATA, dataEntries.length);

        dataEntries.slice(0, visibleCount).forEach(([key, value]) => {
          const dataText = `${key}: ${value}`;
          ctx.fillText(dataText, pos.x + NODE_PADDING, dataY);
          dataY += LINE_HEIGHT;
        });

        if (dataEntries.length > MAX_VISIBLE_DATA) {
          const buttonY = pos.y + pos.height - NODE_PADDING - 26;
          const buttonText = isExpanded ? '‚ñ≤ Show less' : `‚ñº Show ${dataEntries.length - MAX_VISIBLE_DATA} more`;
          
          // Draw button background with same styling as node
          ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
          const buttonRadius = 6;
          ctx.beginPath();
          ctx.roundRect(pos.x + NODE_PADDING, buttonY, pos.width - NODE_PADDING * 2, 26, buttonRadius);
          ctx.fill();
          
          // Draw button border
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.lineWidth = 1;
          ctx.stroke();
          
          ctx.fillStyle = 'white';
          ctx.font = 'bold 11px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(buttonText, pos.x + pos.width / 2, buttonY + 13);
        }
      }
    }

    Initialize();
  </script>
</body>

</html>